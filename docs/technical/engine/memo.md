## 構文解析 (parsing, AST generation)
ソースコードをパーサーで解析する。パーサーはAST(ast::Nodeによる木構造)を生成する。  
ASTでは構造体のサイズを確定させるために、ノードの中に別のノードを入れる場合はBoxやVecで囲んでいる。

## 静的解析 (AST analysis, HIR generation)
ASTをトラバースして、識別子が存在するかどうかや型の矛盾がないかどうかを確認する。  
識別子の解決に必要な情報は名前解決スタックに収集する。  
識別子を見つけた場合は、名前解決スタックから対応する関数や変数へ関連付けを行う。  
また、その他のノードに関する情報(型情報など)はシンボルテーブルに収集し、利用される。  
静的解析ではHIRノード(hir::Node)のグラフを生成する(HIRコード)。  
HIRノードになった後は識別子の代わりにノードIDを使って他のノードを参照できるようになる。

### 名前解決スタック
識別子とHIRノードのIDをペアにして名前解決スタックに登録する。  
そのスコープに存在する全ての識別子にアクセスできる。  
名前解決スタックの構造はレイヤー状になっている。1つのレイヤーには複数のレコードを登録できる。  
現在のレイヤーから親のレイヤーには遡ってアクセスできる。子のレイヤーにはアクセスできない。

### シンボルテーブル
シンボルテーブルでは、各HIRノードに対応する様々な情報(ソースコード上の位置や型情報など)が保持される。

### 型チェック
TODO

### if文
パーサーではできるだけ間違った並びでも読み取るようにして、静的解析でエラーを検出する。  
静的解析でelse if部分をelseのブロックの中にif文がネストしている形としてデシュガーする。

イメージ:
```ts
// before
if cond {

} else if cond {

} else if cond {

} else {

}

// after
if cond {

} else {
    if cond {

    } else {
        if cond {

        } else {

        }
    }
}
```

## インタプリタによる実行 (HIR running)
静的解析で生成したHIRコードをトラバースして処理を実行する。  

### 実行スタック
実行スタックに変数などの値を追加していく。実行スタックの項目はシンボルと呼ぶ。  
HIRノードのIDをシンボルアドレスとして使う。

### 関数コール
元の環境で実引数を評価 -> 環境を分ける(push frame) -> 仮引数に値をセット

### 構造体
構造体は定義してインスタンス化を行ってから使用する。
インタプリタ実行時、構造体の各インスタンス(`Identifier { fields }`)に対して値が生成される。
